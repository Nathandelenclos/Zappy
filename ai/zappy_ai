#!/bin/python3

import sys
import argparse
import socket
import re
import uuid
import math
import random

# from main import temp_evo

uuid_str = str(uuid.uuid4())
port = None
team_name = None
ip_server = None

auto_command = []
last_broadcast = []
last_command = None
last_answer = None
mode = None
presence = False

def printGreen(data):
    print("\033[92m" + data + "\033[0m")

class Game_data:
    def __init__(self):
        self.map_size_x = 0
        self.map_size_y = 0
        self.available_connection = 0
        self.lvl = 1
        self.available = 0
        self.uuid_present = []
        self.stones_in_game = ["linemate", "deraumere", "sibur", "mendiane", "phiras", "thystame"]
        self.evolution_infos  = {
            "lvl2": [1, 1, 0, 0, 0, 0, 0],
            "lvl3": [2, 1, 1, 1, 0, 0, 0],
            "lvl4": [2, 2, 0, 1, 0, 2, 0],
            "lvl5": [4, 1, 1, 2, 0, 1, 0],
            "lvl6": [4, 1, 2, 1, 3, 0, 0],
            "lvl7": [6, 1, 2, 3, 0, 1, 0],
            "lvl8": [6, 2, 2, 2, 2, 2, 1]
        }
        self.inventory  = {
            "food": None,
            "linemate": None ,
            "deraumere": None ,
            "sibur": None ,
            "mendiane": None ,
            "phiras": None ,
            "thystame": None 
        }

myGameData = Game_data()

def manHelp():
    print("USAGE:  ./zappy_ai -p port -n name -h machine")
    print("\tport\tis the port number")
    print("\tname\tis the name of the team")
    print("\tmachine\tis the name of the machine; localhost by default")

def Error_man():
    global port, team_name, ip_server

    if len(sys.argv) == 2:
        if sys.argv[1] == "-help":
            manHelp()
            raise SystemExit()
        else:
            raise Exception("Bad arguments\n")
    elif len(sys.argv) == 5 or len(sys.argv) == 7:
        parser = argparse.ArgumentParser(add_help=False)
        parser.add_argument('-p', type=int)
        parser.add_argument('-n', type=str)
        parser.add_argument('-h', type=str)
        args = parser.parse_args()
        port = args.p
        team_name = args.n
        ip_server = args.h
        if team_name == None or port == None:
            raise Exception("Bad arguments\n")
        if ip_server == None:
            ip_server = "127.0.0.1"
    else:
        raise Exception("Bad arguments\n")

def broadcast_man(data, answer, client_socket, mode):
    global myGameData, presence
    if answer[2] != team_name:
        return ()
    print(data)
    message = data.split(", ")
    if message[1] == team_name+" nb_player" and presence == False:
        print("Broadcast "+team_name+" present "+uuid_str)
        client_socket.send(("Broadcast "+team_name+" present "+uuid_str+"\n").encode())
        data = receive_answer(client_socket)
        presence = True
    elif mode == "asker" and answer[3] == "present":
        if answer[4] in myGameData.uuid_present:
            return ()
        myGameData.uuid_present.append(answer[4])
        myGameData.available += 1
    elif message[1] == team_name+" end nb_player":
        presence = False
    else:
        last_broadcast.append(answer)

def answer_management(data, client_socket, mode):
    global last_broadcast
    if data == "dead":
        print("YOU DIED x)")
        client_socket.close()
        print("Connexion fermée.")
        return (-1)
    else:
        answer = data.split()
        if answer[0] == "message":
            # print(data)
            # last_broadcast.append(answer)
            broadcast_man(data, answer, client_socket, mode)
            return(1)
        print(data)
        return (0)
    
def receive_answer(client_socket, mode=""):
    answer = 1
    while (answer != 0):
        data = read_server(client_socket)
        answer = answer_management(data, client_socket, mode)
    return data

def read_server(client_socket):
    msg = ""
    while (1):
        char_read = client_socket.recv(1)
        if not char_read:
            break
        elif (char_read == b'\n'):
            return (msg)
        else:
            msg += char_read.decode()
    return (msg)

def check_inventory(client_socket):
    global myGameData
    print("Inventory")
    client_socket.send(("Inventory"+"\n").encode())
    data = receive_answer(client_socket)
    clean_string = data.strip("[] ")
    pattern = r"(\w+)\s(\d+)"
    matches = re.findall(pattern, clean_string)
    data = [[name, value] for name, value in matches]
    while (len(data) > 0):
        myGameData.inventory[data[0][0]] = data[0][1]
        data.pop(0)

def find_path(data, item):
    data = data.replace('[', ' ')
    data = data.replace(']', ' ')
    splitData = data.split(",")
    instructions = []
    count = 0
    for i in range(0, len(splitData)):
        if splitData[i].find(item) != -1:
            break;
        count += 1
    if count == len(splitData):
        return ["Forward" for f in range(0, myGameData.lvl)]
    elif (splitData[0].find(item)) != -1:
        return ["Take " + item]
    else:
        fCount = 0
        limit = 1
        tile = 0
        width = 1
        for i in range(0, len(splitData)):
            if i == limit:
                limit += limit + 2
                fCount += 1
                width += 2
            if splitData[i].find(item) != -1:
                for a in range(0, fCount):
                    instructions.append("Forward")
                tile = i
                break
        viewLine = [b for b in range((limit - width), limit)]
        middle = viewLine[int((len(viewLine) / 2))]
        if width > 3:
            middle -= 1
        if tile < middle:
            instructions.append("Left")
            for t in range(0, (middle - tile)):
                instructions.append("Forward")
            instructions.append("Take " + item)
        elif tile > middle:
            instructions.append("Right")
            for t in range(0, (tile - middle)):
                instructions.append("Forward")
            instructions.append("Take " + item)
        else:
            instructions.append("Take " + item)
        return instructions

def search_choice(client_socket, data, item):
    add_command = []
    add_command = find_path(data, item)
    while (len(add_command) > 0):
        auto_command.append(add_command[0])
        add_command.pop(0)
    while (len(auto_command) > 0):
        command = auto_command[0] + "\n"
        print(command, end="")
        auto_command.pop(0)
        client_socket.send(command.encode())
        data = receive_answer(client_socket)
    # for broadcast in last_broadcast:
    #     print(broadcast)

def search_item(client_socket, item, quantity):
    global last_command, mode, auto_command
    while (quantity > int(myGameData.inventory[item])):
        print("Look")
        client_socket.send(("Look"+"\n").encode())
        last_command = "Look"
        mode = item
        data = receive_answer(client_socket)
        search_choice(client_socket, data, item)
        check_inventory(client_socket)
        if (item != "food"):
            if (int(myGameData.inventory["food"]) < 5):
                search_item(client_socket, "food", 30)
    mode = None

def can_evolve(client_socket):
    global myGameData
    can_lvl_up = 0
    lvl = "lvl"+str(myGameData.lvl+1)
    stones_needed = myGameData.evolution_infos[lvl].copy()
    stones_needed.pop(0)
    index = 0
    for stone in stones_needed:
        stone_name = myGameData.stones_in_game[index]
        my_stone = int(myGameData.inventory[stone_name])
        if my_stone < stone:
            search_item(client_socket, stone_name, stone - my_stone)
            can_lvl_up += 1
        index += 1
    if can_lvl_up == 0:
        return (True)
    else:
        return (False)

def go_evolve(client_socket):
    global myGameData
    if myGameData.lvl == 1:
        take_all_on_tile(client_socket)
        print("Set linemate")
        client_socket.send(("Set linemate\n").encode())
        data = receive_answer(client_socket)
        if data == "ok":
            print("Incantation")
            client_socket.send(("Incantation\n").encode())
            data = receive_answer(client_socket)
            if data == "Elevation underway":
                data = receive_answer(client_socket)
                if data == "ko":
                    printGreen("Evolution failed")
                else:
                    printGreen("Evolution is a success")
                    myGameData.lvl += 1
            else:
                printGreen("Evolution failed")
        else:
            printGreen("Item not found in inventory")
    elif presence != True:
        print("Broadcast "+team_name+" nb_player")
        client_socket.send(("Broadcast "+team_name+" nb_player\n").encode())
        data = receive_answer(client_socket, "asker")
        for i in range(0, 4):
            print("Left")
            client_socket.send(("Left"+"\n").encode())
            data = receive_answer(client_socket, "asker")
        print("Broadcast "+team_name+" end nb_player")
        client_socket.send(("Broadcast "+team_name+" end nb_player\n").encode())
        data = receive_answer(client_socket, "asker")
        if myGameData.available >= myGameData.evolution_infos["lvl"+str(myGameData.lvl+1)][0] - 1:
            gathering_mode_and_incantation(client_socket)
        else:
            print("go fork")
            # exit(0)

def drop_items_on_tile(client_socket):
    lvl = "lvl"+str(myGameData.lvl+1)
    stones_needed = myGameData.evolution_infos[lvl].copy()
    stones_needed.pop(0)
    index = 0
    for stone in stones_needed:
        stone_name = myGameData.stones_in_game[index]
        for i in range(0, stone):
            print("Set "+stone_name)
            client_socket.send(("Set "+stone_name+"\n").encode())
            receive_answer(client_socket)
        index += 1

def gathering_mode(client_socket): #Partie de simon path finding broadcast
    return (True)
    # exit (0)

def gathering_mode_and_incantation(client_socket):
    # print("go evolve to lvl "+str(myGameData.lvl+1))
    if gathering_mode(client_socket) == True:
        take_all_on_tile(client_socket)
        drop_items_on_tile()
        print("Incantation")
        client_socket.send(("Incantation\n").encode())
        data = receive_answer(client_socket)
        if data == "Elevation underway":
            data = receive_answer(client_socket)
            if data == "ko":
                printGreen("Evolution failed")
            else:
                printGreen("Evolution is a success")
                myGameData.lvl += 1
        else:
            printGreen("Evolution failed")
    exit(0)

def take_all_on_tile(client_socket):
    print("Look")
    client_socket.send(("Look\n").encode())
    data = receive_answer(client_socket)
    data = data.replace('[', ' ')
    data = data.replace(']', ' ')
    splitData = data.split(",")
    player_tile = splitData[0]
    items_to_take = player_tile.split()
    while (len(items_to_take) > 0):
        if items_to_take[0] == "player":
            items_to_take.pop(0)
        else:
            print("Take "+items_to_take[0])
            client_socket.send(("Take "+items_to_take[0]+"\n").encode())
            data = receive_answer(client_socket)
            items_to_take.pop(0)

def action_choice(client_socket):
    check_inventory(client_socket)
    if (int(myGameData.inventory["food"]) < 20 and mode == None):
        search_item(client_socket, "food", 30)
    else:
        if (can_evolve(client_socket) == True and mode == None):
            go_evolve(client_socket)

def main():
    global auto_command, last_command, last_answer, last_broadcast, myGameData

    client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    try:
        client_socket.connect((ip_server, port))
        print("Connexion au serveur établie.")
        print(read_server(client_socket))
        client_socket.send((team_name+"\n").encode())
        free_places = read_server(client_socket)
        myGameData.available_connection = free_places
        print(free_places)
        map_size = read_server(client_socket).split()
        myGameData.map_size_x = map_size[0]
        myGameData.map_size_y = map_size[1]
        print(map_size[0] + " " + map_size[1])
        while (1):
            action_choice(client_socket)
    except ConnectionRefusedError:
        print("La connexion au serveur a été refusée.")

if __name__ == "__main__":
    try:
        Error_man()
        main()
    except SystemExit:
        exit(0)
    except Exception as error:
        sys.stdout.write(str(error))
        exit(84)
